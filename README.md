# Instalando o Turtlesim

Nesse primeiro projeto n√≥s assumimos que voc√™ j√° possui o ROS2 instalado no seu computador. Para come√ßar vamos instalar o Turtlesim, que √© um simulador simples criado para aprender ROS2.

O Turtlesim pode ser instalado com os seguintes comandos:

```
sudo apt update
sudo apt install ros-humble-turtlesim
```

Para confirmar que tudo est√° correto execute esse comando:

```
ros2 pkg executables turtlesim
```

A sa√≠da deve ser algo assim:
```
turtlesim draw_square
turtlesim mimic
turtlesim turtle_teleop_key
turtlesim turtlesim_node
```


# Motiva√ß√£o 

Completando esse projeto com o turtlesim voc√™ vai aprender os conceito b√°sicos do ROS2. Esses conceitos ser√£o usados em projetos mais complexos que ser√£o desenvolvidos ao longo dos projetos nesse reposit√≥rio.

# Tarefa 1: Introdu√ß√£o Turtlesim üê¢

## Parte 1 : Rodar o turtlesim

O turtlesim √© um simulador simples criado para aprender ROS2 e para se familiarizar com ele voc√™ pode come√ßar executando esse comando:

```
ros2 run turtlesim turtlesim_node
```

Voc√™ dever√° vem uma janela como essa:

![Alt text](assets/imgs/turtlesim.png)

Como voc√™s podem ver √© uma simples janela com fundo azul e uma tartaruga no centro, sem muito o que fazer por enquanto.

## Parte 2 : Usar o comando do teleop_key para movimentar a tartaruga

Agora que voc√™ j√° tem o turtlesim rodando, voc√™ pode usar o comando do teleop_key para movimentar a tartaruga. Para isso abra um novo terminal e execute o seguinte comando:

```
ros2 run turtlesim turtle_teleop_key
```

Voc√™ dever√° ver uma sa√≠da como essa:

![Alt text](assets/imgs/teleop_key_turtlesim.png)

Experimente usar as teclas para movimentar a tartaruga e veja o que acontece.

## Conclus√£o

T√° bom, muito legal uma tartaruga andando em uma simples janela, mas o que isso tem a ver com rob√¥tica? Voc√™ ainda pode n√£o saber, mas a mesma estrutura que voc√™ acaba de usar para controlar essa tartaruga foi usada de diversas maneira para controlar esse robozinho aqui:

![Alt text](assets/imgs/robonaut.jpg)

Esse rob√¥ se chama **Robonaut**, e foi construido pela **NASA** utilizando **ROS2**. Nessa foto ele est√° na Esta√ß√£o Espacial Internacional (ISS) e √© controlado por astronautas da NASA. Ele √© capaz de realizar diversas tarefas na ISS, como por exemplo, trocar baterias e realizar experimentos cient√≠ficos. Se voc√™ quiser ler mais sobre o Robonaut ou sobre ROS2 no espa√ßo, voc√™ pode acessar esse link: [ROS‚Ä¶in‚Ä¶space!](https://www.openrobotics.org/blog/2022/2/2/rosinspace)


# Tarefa 2: Nodes no ROS2

## Parte 1: Criando um novo pacote

Nesta tarefa, iremos desenvolver nosso pr√≥prio n√≥ para controlar uma tartaruga. No entanto, antes de come√ßarmos, precisamos configurar um ambiente chamado 'workspace'. Mas afinal, o que √© um 'workspace'? Em termos simples, um 'workspace' √© um diret√≥rio que cont√©m todos os pacotes necess√°rios para um projeto espec√≠fico. √â como um espa√ßo de trabalho dedicado para sua aplica√ß√£o ROS2.

Para criar um novo pacote dentro do nosso 'workspace', utilizaremos o comando `ros2 pkg create`. Este comando nos permite criar um novo pacote, que √© uma unidade organizacional fundamental no ROS2. Os pacotes s√£o respons√°veis por conter c√≥digo, bibliotecas, recursos e outros elementos necess√°rios para realizar tarefas espec√≠ficas dentro de um sistema. Com a cria√ß√£o deste pacote, estaremos preparados para come√ßar a desenvolver nosso pr√≥prio n√≥ e, assim, iniciar o controle da tartaruga.

Mas antes de criarmos o pacote, vamos primeiro ver a estrutura b√°sica de uma "workspace" do ROS2. A estrutura √© a seguinte:

```
tarefa1_ws/
    build/
    install/
    src/
```

Onde "tarefa1_ws" √© o nome do nosso workspace. O diret√≥rio "src" cont√©m todos os pacotes ROS2 necess√°rios para o nosso projeto. O diret√≥rio "build" cont√©m todos os arquivos de compila√ß√£o gerados durante o processo de compila√ß√£o. O diret√≥rio "install" cont√©m todos os arquivos de instala√ß√£o gerados durante o processo de instala√ß√£o. Veremos o que √© esse processo de compila√ß√£o e instala√ß√£o mais tarde. O que voc√™ precisar criar agora √© o diret√≥rio "tarefa1_ws" e o diret√≥rio "src" dentro dele. Est√£o vamos l√°, abra um terminal e execute os seguintes comandos:

```
mkdir -p tarefa1_ws/src
```

Com isso pronto entre **dentro** do diret√≥rio "src" e execute o seguinte comando:

```
ros2 pkg create --build-type ament_python --node-name hello_world turtlesim_project
```

Agorar vamos ver o que cada parte desse comando significa:

- **ros2 pkg create**: comando para criar um novo pacote
- **--build-type ament_python**: define o tipo de pacote que estamos criando, neste caso um pacote em python
- **--node-name hello_world**: define o nome do n√≥ que estamos criando, neste caso o nome do n√≥ √© hello_world
- **turtlesim_project**: define o nome do pacote que estamos criando, neste caso o nome do pacote √© turtlesim_project

Se tudo deu certo voc√™ ter√° uma estrutura de diretorios como essa:

![Alt text](assets/imgs/package_init_vs_code.png)

## Parte 2: Criando um node

### Afinal, o que √© um node?


Um node no ROS2 √© algo parecido com uma fun√ß√£o, porque ele deve ser modular e respons√°vel apenas por uma a√ß√£o espec√≠fica. Por exemplo, imagine que estamos desenvolvendo um rob√¥ que deve ser capaz de se mover e de reconhecer objetos. Nesse caso, podemos ter dois nodes, um para controlar o movimento do rob√¥ e outro para reconhecer objetos. Esses nodes podem ser executados em paralelo e se comunicar entre si para realizar tarefas mais complexas. √â √≥bvio que esse exemplo √© muito simples, e em uma aplica√ß√£o real ter√≠amos muito mais nodes, mas a ideia √© essa.

![Alt text](assets/gifs/Nodes-TopicandService.gif)

Os nodes se comunicam entre si usando t√≥picos e servi√ßos. Vamos falar mais sobre isso mais tarde, mas por enquanto vamos focar em criar nosso primeiro node.

### Estrutura de um node

Para come√ßarmos crie um arquivo chamado "turtlesim_teleop.py" dentro do diret√≥rio "turtlesim_project/turtlesim_project" e adicione o seguinte c√≥digo:

```python
import rclpy
from rclpy.node import Node

class MyNode(Node):
    def __init__(self):
        super().__init__('my_node')
        self.get_logger().info("Hello World!")

def main(args=None):
    rclpy.init(args=args)
    node = MyNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

Essa √© a estrutura b√°sica de um node em python. Vamos explicar agora as partes mais importantes desse c√≥digo.

```python
import rclpy
from rclpy.node import Node
```

`import rclpy`: Esta linha importa o m√≥dulo rclpy. rclpy √© a biblioteca do cliente Python para o ROS2. Ela fornece as ferramentas necess√°rias para criar e executar nodes usando Python.

`from rclpy.node import Node`: Esta linha importa a classe Node do m√≥dulo rclpy.node. A classe Node √© uma classe fundamental no ROS2 que representa um node.

```python
class MyNode(Node):
    def __init__(self):
        super().__init__('my_node')
        self.get_logger().info("Hello World!")
```

Este trecho de c√≥digo define uma classe chamada `MyNode` que herda da classe `Node` do ROS2. Aqui est√° o que cada linha faz:

- `class MyNode(Node)`: Esta linha define uma nova classe chamada `MyNode` que herda de `Node`. A classe `Node` √© uma classe fundamental no ROS2 que representa um n√≥.

- `def __init__(self)`: Esta linha define o m√©todo construtor para a classe `MyNode`. Este m√©todo √© chamado automaticamente quando voc√™ cria uma nova inst√¢ncia da classe.

- `super().__init__('my_node')`: Esta linha chama o m√©todo construtor da classe pai (`Node`) usando a fun√ß√£o `super()`. Isso permite que voc√™ use os m√©todos e atributos da classe pai na sua subclasse. O argumento `'my_node'` √© o nome do n√≥ e √© passado para o construtor da classe pai.

- `self.get_logger().info("Hello World!")`:  Esta linha usa o m√©todo `get_logger()` para obter o logger associado a este n√≥. O logger √© usado para registrar mensagens de log. O m√©todo `info()` √© usado para registrar uma mensagem de informa√ß√£o. Neste caso, ele registra a mensagem "Hello World!".


```python
def main(args=None):
    rclpy.init(args=args)
    node = MyNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()
```
Aqui est√° o que cada linha faz:

- `rclpy.init(args=args)`: Esta linha inicializa o sistema de comunica√ß√£o do ROS. Isso deve ser chamado antes de usar qualquer outra parte do rclpy. Geralmente, passamos os argumentos da linha de comando para esta fun√ß√£o, que s√£o usados para configura√ß√µes do ROS (como definir vari√°veis de ambiente ROS).

- `node = MyNode()`: Aqui estamos criando uma inst√¢ncia da classe MyNode.

- `rclpy.spin(node)`: Esta fun√ß√£o faz com que o programa entre em um loop, processando callbacks sempre que as mensagens s√£o recebidas nos **t√≥picos** aos quais o n√≥ est√° inscrito, ou quando os servi√ßos fornecidos pelo n√≥ s√£o chamados. O loop continua at√© que seja interrompido (por exemplo, se voc√™ pressionar Ctrl+C).

- `node.destroy_node()`: Depois que o loop √© interrompido, esta linha √© chamada para limpar os recursos associados ao n√≥.

- `rclpy.shutdown()`: Finalmente, esta linha desliga o sistema de comunica√ß√£o do ROS, liberando quaisquer recursos que ele estava usando.

### Executando o node


Primeiro, na pasta raiz do package, acesse o arquivo setup.py e adicione o turltesim_teleop no entry points(vlw Muriki por achar o erro). Seu arquivo deve ficar assim:

```
entry_points={
        'console_scripts': [
            'hello_world = turtlesim_project.hello_world:main',
            'turtlesim_teleop = turtlesim_project.turtlesim_teleop:main'
        ],
    },
```

Agora estamos prontos para executar essa estrutura b√°sica de um node. Para isso abra um novo terminal e v√° at√© o diret√≥rio "tarefa1_ws" e execute o seguinte comando:

```
colcon build
```

O comando acima serve para compilar o pacote que acabamos de criar. Agora execute o seguinte comando:

```
source install/setup.bash
```

Esse comando serve para configurar o ambiente para que o ROS2 possa encontrar o pacote que acabamos de criar. E por fim execute o seguinte comando:

```
ros2 run turtlesim_project turtlesim_teleop
```

Agora voc√™ deve ver uma sa√≠da como essa:

![Alt text](assets/imgs/terminal.png)

Agora o nosso node est√° rodando e voc√™ pode ver a mensagem "Hello World!" sendo impressa no terminal. Em outro terminal voc√™ pode executar o comando `ros2 node list` para ver os nodes que est√£o rodando. Se voc√™ ver o node "my_node" na lista, significa que tudo deu certo.

Para ler mais sobre nodes voc√™ pode acessar esse link: [ROS2 Nodes](https://docs.ros.org/en/humble/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Nodes/Understanding-ROS2-Nodes.html)

# Tarefa 3: Criando um publisher

Agora n√≥s vamos modificar o nosso node para publicar uma mensagem, um node que publica mensagens √© chamado comumente de publisher. O publisher publica mensagens em um t√≥pico, e outros nodes podem se inscrever nesse t√≥pico para receber essas mensagens.

### Mas o que √© exatamente um t√≥pico? Vamos responder usando uma analogia com Star Wars üååüî´

Imagine que os t√≥picos s√£o como canais de comunica√ß√£o entre diferentes naves, planetas ou bases da gal√°xia. Cada t√≥pico tem um nome √∫nico e um tipo de mensagem que define o formato dos dados que s√£o enviados ou recebidos. Por exemplo, o t√≥pico /rebelion pode usar mensagens do tipo string para transmitir mensagens secretas entre os membros da Alian√ßa Rebelde.

Os n√≥s s√£o como os dispositivos ou pessoas que usam esses canais de comunica√ß√£o para trocar informa√ß√µes. Cada n√≥ pode publicar (enviar) ou subscrever (receber) em um ou mais t√≥picos, dependendo da sua fun√ß√£o e interesse. Por exemplo, o n√≥ /luke pode publicar no t√≥pico /force para enviar sinais da For√ßa para outros Jedi, e subscrever no t√≥pico /rebelion para receber instru√ß√µes da Alian√ßa Rebelde.

Os publicadores e assinantes n√£o precisam saber da exist√™ncia uns dos outros, apenas do nome e tipo do t√≥pico que usam. Isso permite uma comunica√ß√£o ass√≠ncrona e flex√≠vel entre os n√≥s, sem depender de uma conex√£o direta ou de uma ordem espec√≠fica. Por exemplo, o n√≥ /leia pode publicar uma mensagem de socorro no t√≥pico /rebelion, sem saber quem vai receb√™-la ou quando. O n√≥ /han pode subscrever esse t√≥pico e responder √† mensagem, sem saber quem a enviou ou de onde.

![Alt text](assets/gifs/topics.gif)

Essa estrutura distribu√≠da do ROS 2 √© muito importante, porque no seu antecessor ROS 1, existia um mestre central que coordenava todas as atividades dos nodes. Isso significa que todos os nodes dependiam desse mestre para se comunicar uns com os outros. No entanto, no ROS 2, cada node √© independente e pode se comunicar diretamente com os outros nodes atrav√©s dos t√≥picos. Isso torna o sistema mais robusto e escal√°vel, pois n√£o h√° um √∫nico ponto de falha.

Voc√™ pode ler mais sobre t√≥picos aqui: [ROS2 Topics](https://docs.ros.org/en/humble/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Topics/Understanding-ROS2-Topics.html)


## Parte 1: M√£o na massa

Abra o arquivo "turtlesim_teleop.py" no seu editor de c√≥digo de prefer√™ncia e vamos come√ßar alterando a classe "MyNode" para que ela publique mensagens no t√≥pico "/my_first_topic". A primeira coisa que vamos precisar √© adicionar essas linhas no construtor da classe.

```python
 def __init__(self):
        super().__init__('my_node')
        self.publisher_ = self.create_publisher(String, 'my_first_topic', 10)
        timer_period = 0.5 
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0
```

O construtor da classe est√° criando um publicador que envia mensagens do tipo String para o t√≥pico "my_first_topic". Ele tamb√©m est√° criando um timer que chama a fun√ß√£o "timer_callback" a cada 0.5 segundos. Vamos criar a fun√ß√£o "timer_callback" mais adiante. 

Para a linha `self.publisher_ = self.create_publisher(String, 'my_first_topic', 10)` vamos explicar o que cada parte significa:

- `self.publisher_`: Esta √© uma vari√°vel de inst√¢ncia que armazena o publicador que voc√™ est√° criando. O uso de um sublinhado no final (_) √© uma conven√ß√£o comum em Python para indicar que esta vari√°vel √© destinada a uso interno dentro da classe e n√£o deve ser acessada diretamente.

- `self.create_publisher`: Este √© um m√©todo fornecido pela classe Node em ROS2. Ele cria um publicador que pode enviar mensagens a um t√≥pico.

- `String`: Este √© o tipo de mensagem que o publicador ir√° enviar. Neste caso, ele est√° configurado para enviar mensagens do tipo String.

- `'my_first_topic'`: Este √© o nome do t√≥pico ao qual o publicador enviar√° mensagens. Voc√™ pode escolher qualquer nome que quiser, desde que seja √∫nico dentro do seu sistema ROS.

- `10`: Este √© o tamanho da fila de mensagens para o publicador. Se o publicador estiver enviando mensagens mais r√°pido do que elas podem ser processadas, ele armazenar√° at√© 10 mensagens nesta fila. Isso se chama QoS (Quality of Service) e n√£o √© muito importante para n√≥s agora, mas voc√™ pode ler mais sobre isso aqui: [ROS2 QoS](https://docs.ros.org/en/humble/Tutorials/Quality-of-Service.html)

Tamb√©m √© ness√°rio adicionar o import da classe String no in√≠cio do arquivo:

```python
    ...
    from std_msgs.msg import String
    ...
```

Agora vamos criar a fun√ß√£o "timer_callback" que ser√° chamada a cada 0.5 segundos.

```python
 def timer_callback(self):
        msg = String()
        msg.data = 'Hello World: %d' % self.i
        self.publisher_.publish(msg)
        self.get_logger().info('Publishing: "%s"' % msg.data)
        self.i += 1
```

Essa fun√ß√£o cria uma mensagem do tipo String, define o valor da mensagem e publica a mensagem no t√≥pico "my_first_topic". A fun√ß√£o tamb√©m registra uma mensagem de log para informar que a mensagem foi publicada. A parte mais interessante dessa fun√ß√£o √© a linha `self.publisher_.publish(msg)` que usa o publicador que criamos anteriormente para publicar a mensagem no t√≥pico "my_first_topic".


Pronto, voc√™ j√° criou seu primeiro publisher. Agora vamos compilar o pacote e executar o node para ver o que acontece. Mas agora vamos fazer isso utilizando o comando `colcon build --symlink-install`. Esse comando serve para criar um link simb√≥lico para o pacote que estamos desenvolvendo. Isso significa que se voc√™ alterar o c√≥digo do pacote, n√£o ser√° necess√°rio compilar novamente para que as altera√ß√µes sejam aplicadas. Na pasta "tarefa1_ws" execute o seguinte comando:

```
colcon build --symlink-install
```

Agora rode o node com o seguinte comando:

```
ros2 run turtlesim_project turtlesim_teleop 
```

Voc√™ dever√° ver uma sa√≠da como essa:

![Alt text](assets/imgs/first_publisher.png)


J√° que falamos de Star Wars aqui, vou sugerir um exerc√≠cios simples para voc√™s. Crie um node chamado /chewbacca que publica mensagens do tipo String no t√≥pico /wookie_sounds. Seja criativo e tente transcrever os sons que o Chewbacca faz em texto.

E agora que voc√™ j√° criou um publisher, que tal criar um subscriber? Vamos l√°!

# Tarefa 4: Criando um subscriber

Agora vamos criar um novo arquivo chamado "turtlesim_subscriber.py" dentro do diret√≥rio "turtlesim_project/turtlesim_project". Antes de come√ßarmos a escrever o c√≥digo, tente voc√™ mesmo criar um subscriber que se inscreve no t√≥pico "my_first_topic" e imprime as mensagens recebidas. Se voc√™ n√£o conseguir, n√£o se preocupe, vamos fazer isso juntos agora.

Copie e cole o c√≥digo que voc√™ escreveu no arquivo "turtlesim_teleop.py" para o arquivo "turtlesim_subscriber.py". Agora vamos alterar o construtor da classe "MyNode" para que ela se inscreva no t√≥pico "my_first_topic". O construtor da classe deve ficar assim:

```python
class MyNode(Node):
    def __init__(self):
        super().__init__('my_node')
        self.subscriber = self.create_subscription(String, 'my_first_topic', self.subscriber_callback, 10)
```

Ao criar um subscriber passamos os mesmos par√¢metros que passamos para o publisher, com exce√ß√£o da mensagem que √© recebida e da fun√ß√£o que √© chamada quando uma mensagem √© recebida. A fun√ß√£o "subscriber_callback" ser√° chamada sempre que uma mensagem for recebida no t√≥pico "my_first_topic". Agora vamos criar essa fun√ß√£o:


```python
def subscriber_callback(self, msg):
        print('I heard: [%s]' % msg.data)
```

Simples, n√£o √©? Voc√™ pode apagar a fun√ß√£o "timer_callback" que criamos anteriormente, pois n√£o vamos mais us√°-la nesse arquivo. Agora vamos compilar o pacote e executar o node para ver o que acontece. Execute o processo de compila√ß√£o como visto anteriormente.

Ap√≥s compilar o pacote, execute o seguinte comando para executar o node:

```
ros2 run turtlesim_project turtlesim_subscriber 
```

Deu certo? N√£o? Voc√™ deve ter visto uma mensagem reclamando de `no executable found` ou algo relacionado a `importlib_load_entry_point`.

Isso aconteceu porque o ROS2 n√£o sabe que o arquivo "turtlesim_subscriber.py" √© um node. Para resolver isso, vamos alterar o arquivo "setup.py".

## Arquivo setup.py

O arquivo `setup.py` √© usado para configurar a instala√ß√£o de pacotes Python, incluindo ROS2. Os "entry points" s√£o uma caracter√≠stica desse arquivo que permite a cria√ß√£o de comandos de terminal a partir de fun√ß√µes Python. No ROS2, eles s√£o usados para expor n√≥s e comandos para outros pacotes.

Pense no arquivo setup.py como o manual de instru√ß√µes para montar um brinquedo de blocos. Ele diz ao Python (o montador) como montar e onde colocar cada pe√ßa (os m√≥dulos e scripts do pacote).

Os ‚Äúentry points‚Äù s√£o como as portas especiais que voc√™ coloca em sua constru√ß√£o. Eles permitem que outras pessoas (outros pacotes) interajam com sua constru√ß√£o de maneiras espec√≠ficas, como abrir uma porta para ver dentro ou usar um comando para ativar uma fun√ß√£o.

Agora vamos criar um `entry point` para o nosso node adicionando a seguinte linha no arquivo "setup.py":

```python 
    ...
    entry_points={
        'console_scripts': [
            'turtlesim_teleop = turtlesim_project.turtlesim_teleop:main',
            'turtlesim_subscriber = turtlesim_project.turtlesim_subscriber:main',
        ],
    },
    ...
```

Refa√ßa o processo de compila√ß√£o e tente executar o node novamente. Agora deve funcionar.

Se nada est√° sendo impresso no terminal, √© porque o node n√£o est√° recebendo nenhuma mensagem. Para resolver isso, abra um novo terminal e execute o publisher que criamos `turtlesim_teleop`. Agora voc√™ deve ver as mensagens sendo impressas no terminal.

![Alt text](assets/imgs/publisher_subscriber.png)

Pronto, voc√™ fez dois nodes se comunicarem usando t√≥picos. Esses nodes poderiam ser um informa√ß√µes de um sensor e um node que processa essas informa√ß√µes, ou um node que controla um rob√¥ e um node que recebe comandos para controlar esse rob√¥. As possibilidades s√£o infinitas.

Agora vamos usar isso que aprendemos para realmente controlar a tartaruga.

# Tarefa 5: Mensagens Personalizadas no ROS2

At√© agora n√≥s usamos mensagens do tipo String para publicar e assinar mensagens. No entanto, o ROS2 possui uma grande variedade de mensagens pr√©-definidas que podem ser usadas para diferentes aplica√ß√µes. Voc√™ pode ver a lista completa dessas mensagens aqui: [ROS2 Messages](https://docs.ros.org/en/humble/Concepts/Basic/About-Interfaces.html#id2) OBS: Nesse link √© falado sobre `interfaces`, que √© uma abstra√ß√£o para `topics`(que j√° vimos), `services`(que veremos mais tarde) e `actions`(que veremos mais tarde).

Mas que tipo de mensagem devemos usar para controlar a tartaruga? Uma String n√£o parece ser o tipo de mensagem mais adequado para isso.

## Descobrindo o tipo de mensagem de um t√≥pico

Como o node que recebe os comandos da tartaruga j√° est√° implementado temos que usar o mesmo tipo de mensagem que ele espera receber. Para descobrir qual √© o tipo de mensagem que o node espera receber, vamos fazer o seguinte:

- 1¬∞ Passo: Abra um novo terminal e execute o node do turtlesim `ros2 run turtlesim turtlesim_node` 
- 2¬∞ Passo: Use o comando `ros2 topic list` para listar os t√≥picos que est√£o sendo publicados e assinados no momento.
- 3¬∞ Passo: Voc√™ devera ver o topico "/turtle1/cmd_vel" na lista. Esse √© o t√≥pico que o node do turtlesim espera receber mensagens para controlar a tartaruga.
- 4¬∞ Passo: Use o comando `ros2 topic info /turtle1/cmd_vel` para ver o tipo de mensagem que esse t√≥pico espera receber.

A saida deve ser algo assim:

```
Type: geometry_msgs/msg/Twist
Publisher count: 0
Subscription count: 1
```

Ent√£o o tipo de mensagem que o node espera receber √© `geometry_msgs/msg/Twist`. Agora vamos ver como √© essa mensagem.

## Explicando Geometry_msgs/msg/Twist

A mensagem `geometry_msgs/msg/Twist` √© um tipo de mensagem definido no pacote geometry_msgs. Essa mensagem √© usada para representar velocidades lineares e angulares em um sistema de coordenadas tridimensional. Ela cont√©m os seguintes campos:

- linear: um vetor com tr√™s componentes (x, y, z) que representa a velocidade linear nas dire√ß√µes x, y e z.
- angular: um vetor com tr√™s componentes (x, y, z) que representa a velocidade angular em torno dos eixos x, y e z.

![Alt text](assets/imgs/turtlesim-tutorial.png)

Como o ambiente do turtlesim √© 2D, no linear n√≥s s√≥ precisamos nos preocupar com a velocidade linear nas dire√ß√µes x e y. J√° no angular n√≥s s√≥ precisamos nos preocupar com a velocidade angular em torno do eixo z.

# Tarefa 6: Finalmente, controlando a tartaruga

Antes de continuar tente voc√™ criar um node que receba uma entrada do teclado e publique mensagens do tipo `geometry_msgs/msg/Twist` no t√≥pico `/turtle1/cmd_vel`. Utilize as setas para controlar a velocidade linear e as letra 'a' e 'd' para a velocidade angular. Se voc√™ n√£o conseguir, n√£o se preocupe, vamos fazer isso juntos agora.

Primeiro, vamos mudar o nome da classe 'MyNode' para 'TurtlesimTeleop'. Depois disso vamor importar o tipo de mensagem que vamos usar:

```python
from geometry_msgs.msg import Twist
```

Importe o pynput para ler as entradas do teclado:

```python
from pynput import keyboard
```

Caso n√£o tenha o pynput instalado, voc√™ pode instalar com o seguinte comando:

```
pip3 install pynput
```

Vamos agora alterar o construtor do nosso node para que ele crie um publicador que envia mensagens do tipo `geometry_msgs/msg/Twist` para o t√≥pico `/turtle1/cmd_vel`:

```python
class TurtlesimTeleop(Node):
    turtle_linear_speed = 1.0
    turtle_angular_speed = 2.0

    def __init__(self):
        super().__init__('my_node')
        self.publisher_ = self.create_publisher(Twist, '/turtle1/cmd_vel', 10)
        self.key_listener = keyboard.Listener(on_press=self.on_press)
        self.key_listener.start()
```

A linha `self.key_listener = keyboard.Listener(on_press=self.on_press)` est√° criando um objeto Listener da biblioteca keyboard. Este objeto √© respons√°vel por ‚Äúouvir‚Äù quando uma tecla √© pressionada no teclado.

O par√¢metro on_press=self.on_press √© uma fun√ß√£o de callback que ser√° chamada toda vez que uma tecla for pressionada. Neste caso, a fun√ß√£o self.on_press ser√° chamada.

Ent√£o, essa linha de c√≥digo est√° dizendo: ‚ÄúCrie um Listener para o teclado e, sempre que uma tecla for pressionada, chame a fun√ß√£o self.on_press‚Äù. 

Agora, vamos implementar a fun√ß√£o `on_press`, ela vai conter a l√≥gica que far√° a tartaruga se mover:

```python
    def on_press(self, key):
        msg = Twist()

        if (key == keyboard.Key.up):
            msg.linear.x = self.turtle_linear_speed  
        elif (key == keyboard.Key.down):
            msg.linear.x = -self.turtle_linear_speed 
        elif (key == keyboard.Key.left):
            msg.linear.y = self.turtle_linear_speed
        elif (key == keyboard.Key.right):
            msg.linear.y = -self.turtle_linear_speed
        elif (key == keyboard.KeyCode(char='a')):
            msg.angular.z = self.turtle_angular_speed
        elif (key == keyboard.KeyCode(char='d')):
            msg.angular.z = -self.turtle_angular_speed

        self.publisher_.publish(msg)
```

O `turtle_linear_speed` e o `turtle_angular_speed` s√£o definidos no come√ßo da classe, fique a vontade para alterar esses valores e ver o que acontece.

O c√≥digo final ficar√° assim:

```python
import rclpy
from rclpy.node import Node
from pynput import keyboard
from geometry_msgs.msg import Twist

class TurtlesimTeleop(Node):
    turtle_linear_speed = 1.0
    turtle_angular_speed = 2.0

    def __init__(self):
        super().__init__('my_node')
        self.publisher_ = self.create_publisher(Twist, '/turtle1/cmd_vel', 10)
        self.key_listener = keyboard.Listener(on_press=self.on_press)
        self.key_listener.start()

    def on_press(self, key):
        msg = Twist()

        if (key == keyboard.Key.up):
            msg.linear.x = self.turtle_linear_speed  
        elif (key == keyboard.Key.down):
            msg.linear.x = -self.turtle_linear_speed 
        elif (key == keyboard.Key.left):
            msg.linear.y = self.turtle_linear_speed
        elif (key == keyboard.Key.right):
            msg.linear.y = -self.turtle_linear_speed
        elif (key == keyboard.KeyCode(char='a')):
            msg.angular.z = self.turtle_angular_speed
        elif (key == keyboard.KeyCode(char='d')):
            msg.angular.z = -self.turtle_angular_speed
        

        self.publisher_.publish(msg)

def main(args=None):
    rclpy.init(args=args)
    keyboard_publisher = TurtlesimTeleop()
    rclpy.spin(keyboard_publisher)
    keyboard_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

Agora, compile o pacote e execute o node. Voc√™ deve ver a tartaruga se movendo quando voc√™ pressiona as teclas do teclado.


![Alt text](assets/gifs/final.gif)


# Conclus√£o

Parab√©ns, voc√™ controlou a tartaruga usando ROS2. Agora voc√™ pode criar um node que recebe informa√ß√µes de um sensor e controla a tartaruga, ou um node que recebe comandos de um joystick e controla a tartaruga. As possibilidades s√£o infinitas.

O turtlesim √© apenas um simulado simples, coisas mais legais podem ser feitas usando o Gazebo. Vamos ver isso em outros projetos.

OBS: Voc√™ pode melhorar o c√≥digo de controle e tamb√©m deixar a interface mais bonita. Fique a vontade para fazer isso.
